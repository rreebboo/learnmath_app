rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions for validation and security
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return request.auth != null && request.auth.uid == userId;
    }
    
    function isValidUserData() {
      return request.resource.data.keys().hasAll(['name', 'avatar', 'totalScore', 'lessonsCompleted', 'currentStreak', 'createdAt', 'lastLoginDate'])
        && request.resource.data.name is string
        && request.resource.data.name.size() > 0
        && request.resource.data.name.size() <= 50
        && request.resource.data.avatar is string
        && request.resource.data.avatar.size() <= 10
        && request.resource.data.totalScore is number
        && request.resource.data.totalScore >= 0
        && request.resource.data.lessonsCompleted is number
        && request.resource.data.lessonsCompleted >= 0
        && request.resource.data.currentStreak is number
        && request.resource.data.currentStreak >= 0;
    }
    
    function isValidScoreUpdate() {
      // Only allow score increases, not decreases (prevent cheating)
      return !resource.data.keys().hasAny(['totalScore']) || 
        request.resource.data.totalScore >= resource.data.totalScore;
    }
    
    function isValidPracticeSession() {
      return request.resource.data.keys().hasAll(['topic', 'score', 'totalQuestions', 'correctAnswers', 'completedAt'])
        && request.resource.data.topic is string
        && request.resource.data.topic.size() > 0
        && request.resource.data.score is number
        && request.resource.data.score >= 0
        && request.resource.data.score <= 1000 // Max score per session
        && request.resource.data.totalQuestions is number
        && request.resource.data.totalQuestions > 0
        && request.resource.data.totalQuestions <= 50 // Max questions per session
        && request.resource.data.correctAnswers is number
        && request.resource.data.correctAnswers >= 0
        && request.resource.data.correctAnswers <= request.resource.data.totalQuestions
        && request.resource.data.completedAt is timestamp;
    }

    function canReadLeaderboardData() {
      // Allow reading basic user info needed for leaderboard
      return isAuthenticated();
    }

    // Users collection - Core user profiles
    match /users/{userId} {
      // Read: Users can read their own data + limited leaderboard data for others
      allow read: if isAuthenticated() && (
        isOwner(userId) || 
        canReadLeaderboardData()
      );
      
      // Create: Only authenticated users can create their own profile
      allow create: if isAuthenticated() 
        && isOwner(userId)
        && isValidUserData()
        && request.resource.data.uid == request.auth.uid;
      
      // Update: Users can only update their own profile with valid data
      allow update: if isAuthenticated() 
        && isOwner(userId)
        && isValidScoreUpdate()
        // Prevent changing uid and createdAt if they exist
        && (!resource.data.keys().hasAny(['uid']) || request.resource.data.uid == resource.data.uid)
        && (!resource.data.keys().hasAny(['createdAt']) || request.resource.data.createdAt == resource.data.createdAt);
      
      // Delete: Users can delete their own profile
      allow delete: if isAuthenticated() && isOwner(userId);

      // Practice sessions subcollection
      match /practice_sessions/{sessionId} {
        // Read: Users can only read their own practice sessions
        allow read: if isAuthenticated() && isOwner(userId);
        
        // Create: Users can only create their own practice sessions
        allow create: if isAuthenticated() 
          && isOwner(userId)
          && isValidPracticeSession();
        
        // Update: Allow corrections within 5 minutes to prevent abuse
        allow update: if isAuthenticated() 
          && isOwner(userId)
          && isValidPracticeSession()
          && (timestamp.date(resource.data.completedAt).toMillis() + 300000) > timestamp.date(request.time).toMillis();
        
        // Delete: Generally not allowed to preserve data integrity
        allow delete: if isAuthenticated() && isOwner(userId) && 
          // Allow deletion within 1 minute for immediate corrections
          (timestamp.date(resource.data.completedAt).toMillis() + 60000) > timestamp.date(request.time).toMillis();
      }

      // Topic progress subcollection
      match /topic_progress/{topicId} {
        // Read: Users can read their own topic progress
        allow read: if isAuthenticated() && isOwner(userId);
        
        // Create/Update: Users can update their own topic progress
        allow create, update: if isAuthenticated() 
          && isOwner(userId)
          && request.resource.data.keys().hasAll(['topicId', 'lessonsCompleted', 'stars', 'lastUpdated'])
          && request.resource.data.topicId is string
          && request.resource.data.topicId.size() > 0
          && request.resource.data.lessonsCompleted is number
          && request.resource.data.lessonsCompleted >= 0
          && request.resource.data.lessonsCompleted <= 1000
          && request.resource.data.stars is number
          && request.resource.data.stars >= 0
          && request.resource.data.stars <= 3
          && request.resource.data.lastUpdated is timestamp;
        
        // Delete: Allow users to reset their progress if needed
        allow delete: if isAuthenticated() && isOwner(userId);
      }
    }

    // Friends/Social features (if implemented)
    match /friendships/{friendshipId} {
      // Read: Users can read friendships they're part of
      allow read: if isAuthenticated() && 
        resource != null && (
          request.auth.uid == resource.data.user1Id ||
          request.auth.uid == resource.data.user2Id
        );
      
      // Create: Users can create friend requests they're part of
      allow create: if isAuthenticated() && (
        request.auth.uid == request.resource.data.user1Id ||
        request.auth.uid == request.resource.data.user2Id
      );
      
      // Update: Users can accept/decline friend requests they're involved in
      allow update: if isAuthenticated() && 
        resource != null && (
          request.auth.uid == resource.data.user1Id ||
          request.auth.uid == resource.data.user2Id
        );
      
      // Delete: Users can remove friendships they're part of
      allow delete: if isAuthenticated() && 
        resource != null && (
          request.auth.uid == resource.data.user1Id ||
          request.auth.uid == resource.data.user2Id
        );
    }

    // Challenge/Battle results (if implemented)
    match /battles/{battleId} {
      // Read: Participants can read battle results
      allow read: if isAuthenticated() && 
        resource != null && (
          request.auth.uid == resource.data.player1Id ||
          request.auth.uid == resource.data.player2Id
        );
      
      // Create: Authenticated users can create battles they participate in
      allow create: if isAuthenticated() && (
        request.auth.uid == request.resource.data.player1Id ||
        request.auth.uid == request.resource.data.player2Id
      );
      
      // Update: Participants can update battle results (only if pending)
      allow update: if isAuthenticated() && 
        resource != null &&
        resource.data.status == 'pending' && (
          request.auth.uid == resource.data.player1Id ||
          request.auth.uid == resource.data.player2Id
        );
      
      // Delete: Not allowed to preserve competitive integrity
      allow delete: if false;
    }

    // Global app settings/configurations (read-only for users)
    match /app_config/{configId} {
      // Read: All authenticated users can read app config
      allow read: if isAuthenticated();
      
      // Write: Reserved for admin/server-side operations
      allow write: if false;
    }

    // Achievements/Badges definitions (read-only)
    match /achievements/{achievementId} {
      // Read: All authenticated users can read available achievements
      allow read: if isAuthenticated();
      
      // Write: Only system/admin can create achievements
      allow write: if false; // Handle server-side with Cloud Functions
    }

    // User achievements (earned badges)
    match /users/{userId}/achievements/{achievementId} {
      // Read: Users can read their own achievements
      allow read: if isAuthenticated() && isOwner(userId);
      
      // Write: Only system can award achievements (prevent cheating)
      // This should be handled server-side with Cloud Functions
      allow write: if false;
    }

    // Leaderboard data (if you want a separate collection for caching)
    match /leaderboards/{leaderboardId} {
      // Read: All authenticated users can read leaderboard data
      allow read: if isAuthenticated();
      
      // Write: Only system can update leaderboards
      allow write: if false; // Handle with Cloud Functions for performance
    }

    // Report inappropriate content
    match /reports/{reportId} {
      // Create: Users can report content
      allow create: if isAuthenticated() && 
        request.auth.uid == request.resource.data.reporterId;
      
      // Read/Update/Delete: Only admin (handle server-side)
      allow read, update, delete: if false;
    }

    // Explicitly deny all other paths not covered above
    match /{document=**} {
      allow read, write: if false;
    }
  }
}